// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel FillTexture
#pragma kernel RenderHeightMap
#pragma kernel HandleNewWaves
#pragma kernel DiffuseDensity
#pragma kernel DiffuseVelocity
#pragma kernel HandleCollision;
#pragma kernel UpdateDensityAlongVelocityField;
#pragma kernel UpdateVelocityAlongVelocityField

//Functions
int2 GetClampedCoord(int2 pos);

struct NewWaveData
{
    float2 normalisedPosition;
    float strength;
};

RWTexture2D<float4> TargetTexture;

Texture2D<float4> VelocityFieldIN;
RWTexture2D<float4> VelocityFieldOUT;

Texture2D<float> DensityFieldIN;
RWTexture2D<float> DensityFieldOUT;

Texture2D<float4> CollisionTexture;

StructuredBuffer<NewWaveData> NewWaveBuffer;

float DeltaTime;
float DiffuseRate;

float SpeedScalar;

int TextureSize;

//FillTextureKernelONLY
float4 TextureFillValue;
RWTexture2D<float4> TextureToFill;


[numthreads(8, 8, 1)]
void FillTexture(uint3 id : SV_DispatchThreadID)
{
    TextureToFill[id.xy] = TextureFillValue;
}

[numthreads(8, 1, 1)]
void HandleNewWaves(uint3 id : SV_DispatchThreadID)
{
    int2 pos = NewWaveBuffer[id.x].normalisedPosition * TextureSize;
    DensityFieldOUT[pos].r = DensityFieldOUT[pos].r + NewWaveBuffer[id.x].strength;
    
    const int2 OFFSETLEFT = int2(-1, 0);
    const int2 OFFSETRIGHT = int2(1, 0);
    const int2 OFFSETUP = int2(0, 1);
    const int2 OFFSETDOWN = int2(0, -1);
    
    VelocityFieldOUT[pos + OFFSETLEFT] = VelocityFieldOUT[pos + OFFSETLEFT] + float4(OFFSETLEFT, 0, 1);
    VelocityFieldOUT[pos + OFFSETRIGHT] = VelocityFieldOUT[pos + OFFSETRIGHT] + float4(OFFSETRIGHT, 0, 1);
    VelocityFieldOUT[pos + OFFSETUP] = VelocityFieldOUT[pos + OFFSETUP] + float4(OFFSETUP, 0, 1);
    VelocityFieldOUT[pos + OFFSETDOWN] = VelocityFieldOUT[pos + OFFSETDOWN] + float4(OFFSETDOWN, 0, 1);
}

[numthreads(8, 8, 1)]
void DiffuseDensity(uint3 id : SV_DispatchThreadID)
{
    const int2 OFFSETLEFT = int2(-1, 0);
    const int2 OFFSETRIGHT = int2(1, 0);
    const int2 OFFSETUP = int2(0, 1);
    const int2 OFFSETDOWN = int2(0, -1);
    
    float lossScalar = DiffuseRate * DeltaTime * TextureSize * TextureSize;
    //float lossThisFrame = 4 * lossScalar * DensityFieldIN[id.xy].x;
    float gainThisFrame 
    = lossScalar * (DensityFieldIN[GetClampedCoord(id.xy + OFFSETLEFT)] 
    + DensityFieldIN[GetClampedCoord(id.xy + OFFSETRIGHT)]
    + DensityFieldIN[GetClampedCoord(id.xy + OFFSETUP)]
    + DensityFieldIN[GetClampedCoord(id.xy + OFFSETDOWN)]);
    
    DensityFieldOUT[id.xy].x = (DensityFieldIN[id.xy].x + gainThisFrame) / (1 + 4 * lossScalar);
    DensityFieldOUT[id.xy].x = clamp(DensityFieldOUT[id.xy].x, 0, 1);

}

[numthreads(8, 8, 1)]
void DiffuseVelocity(uint3 id : SV_DispatchThreadID)
{
    const int2 OFFSETLEFT = int2(-1, 0);
    const int2 OFFSETRIGHT = int2(1, 0);
    const int2 OFFSETUP = int2(0, 1);
    const int2 OFFSETDOWN = int2(0, -1);
    
    float lossScalar = DiffuseRate * DeltaTime;
    float4 gainThisFrame
    = lossScalar * (VelocityFieldIN[id.xy + OFFSETLEFT]
    + VelocityFieldIN[id.xy + OFFSETRIGHT]
    + VelocityFieldIN[id.xy + OFFSETUP] 
    + VelocityFieldIN[id.xy + OFFSETDOWN]);
    
    VelocityFieldOUT[id.xy] = (VelocityFieldIN[id.xy] + gainThisFrame) / (1 + 4 * lossScalar);
    VelocityFieldOUT[id.xy] = clamp(VelocityFieldOUT[id.xy], -1, 1);

}

[numthreads(8, 8, 1)]
void UpdateDensityAlongVelocityField(uint3 id : SV_DispatchThreadID)
{
    float scalar = DeltaTime * TextureSize * SpeedScalar;
    float2 offsetPos = id.xy - scalar * VelocityFieldIN[id.xy].xy;
    offsetPos = clamp(offsetPos, 0.5f, TextureSize + 0.5f);
    int2 offsetPosInt = int2(offsetPos);
    
    float xPerc1 = offsetPos.x - offsetPosInt.x;
    float xPerc2 = 1 - xPerc1;
    float yPerc1 = offsetPos.y - offsetPosInt.y;
    float yPerc2 = 1 - yPerc1;
    
    DensityFieldOUT[id.xy]
        = xPerc2 * (yPerc2 * DensityFieldIN[offsetPosInt]               + yPerc1 * DensityFieldIN[offsetPosInt + int2(0, 1)])
        + xPerc1 * (yPerc2 * DensityFieldIN[offsetPosInt + int2(1, 0)]  + yPerc1 * DensityFieldIN[offsetPosInt + int2(1, 1)]);
    
}

[numthreads(8, 8, 1)]
void UpdateVelocityAlongVelocityField(uint3 id : SV_DispatchThreadID)
{
    float scalar = DeltaTime * TextureSize * SpeedScalar;
    float2 offsetPos = id.xy - scalar * VelocityFieldIN[id.xy].xy;
    offsetPos = clamp(offsetPos, 0.5f, TextureSize + 0.5f);
    int2 offsetPosInt = int2(offsetPos);
    
    //Handle Edge Case
    float xPerc1 = offsetPos.x - offsetPosInt.x;
    float xPerc2 = 1 - xPerc1;
    float yPerc1 = offsetPos.y - offsetPosInt.y;
    float yPerc2 = 1 - yPerc1;
    
    VelocityFieldOUT[id.xy]
        = xPerc2 * (yPerc2 * VelocityFieldIN[offsetPosInt]              + yPerc1 * VelocityFieldIN[offsetPosInt + int2(0, 1)])
        + xPerc1 * (yPerc2 * VelocityFieldIN[offsetPosInt + int2(1, 0)] + yPerc1 * VelocityFieldIN[offsetPosInt + int2(1, 1)]);
    
    //Velocity updates not yet perfect, inactive cells stay inactive
}

[numthreads(8, 8, 1)]
void HandleCollision(uint3 id : SV_DispatchThreadID)
{
    float width;
    float height;
    CollisionTexture.GetDimensions(width, height);
    float textureScalar = width / TextureSize;
    
    VelocityFieldOUT[id.xy] = VelocityFieldOUT[id.xy] * (1 - CollisionTexture[id.xy * textureScalar].g);
    DensityFieldOUT[id.xy] = DensityFieldOUT[id.xy] * (1 - CollisionTexture[id.xy * textureScalar].g);
}

int2 GetClampedCoord(int2 pos)
{
    //return min(TextureSize-1, max(pos, 0));
    return clamp(pos, 0, TextureSize - 1);
}

[numthreads(8, 8, 1)]
void RenderHeightMap(uint3 id : SV_DispatchThreadID)
{
    float width;
    float height;
    CollisionTexture.GetDimensions(width, height);
    float textureScalar = width / TextureSize;
    
    float4 velValue = VelocityFieldIN[id.xy];
    velValue.xy = velValue.xy / 2.f + 0.5f;
    TargetTexture[id.xy] = float4(0, 0, DensityFieldIN[id.xy], 1);
    //TargetTexture[id.xy] = float4(velValue.xy, 0, 1);
    //TargetTexture[id.xy] = float4(velValue.xy, DensityFieldIN[id.xy], 1);
        //+ velValue;
        //+ CollisionTexture[id.xy * textureScalar].g;
}
